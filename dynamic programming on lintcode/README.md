
种类
    计数
    最值
    存在性


转移方程
    最后一步
    找出选择性
临界条件

打印路径
优化空间/时间

优化时间的典型：516（怎么只遍历一次性将最小值和次小值取出来）

复习:
    191
    553
    392
    149
    150
    151
    76
    563
    564
    440
    667
    396
    119
    154
    668
类似相邻的两栋房子不能是相同的颜色这种需要知道前一个状态的动态规划，需要将前一个的状态记下来 515
如果太复杂，则可以将问题分解 553
优化时间的典型：516（怎么只遍历一次性将最小值和次小值取出来）
```
    int min1, min2, id1, id2;
    min1 = min2 = INT_MAX;
    for(int j=0; j<costs[0].size(); j++) {
        if(dp[i][j] < min1) {
            min2 = min1;
            id2 = id1;      // 这里虽然刚开始min1和id1都未定义，但是当找到次小值时min2和id2会再次赋值
            min1 = dp[i][j];
            id1 = j;
        } else {    // 这里处理了最小值和次小值相等的情况
            if(dp[i][j] < min2) {
                min2 = dp[i][j];
                id2 = j;
            }
        }
    }
```
优化时间：
    数学定义式简化
    逻辑简化
## 动态规划
状态转移方程，每一步选择化
动态规划的状态转移方程的实质是将当前想要的结果由之前的信息来推断，这里之前的信息代表之前的状态的整体

状态转移方程的构成：
最后一步处于的状态+每一步的选择


积累型动态规划：
二元化一元
    leetcode 53
    lintcode 191
序列型动态规划：
    需要知道前面一个的状态的情况(dp[i]表示还没处理i时的情况) lintcode 515
滚动数组动态规划：
    lintcode 110 行滚动与列滚动(行少列多与行多列少，主要为了节省更多空间)
打破常规思维动态规划：
    lintcode 553
位操作型动态规划
    lintcode 664
可以打印出路径的动态规划：
    将决策存起来 lintcode 110
圈型(序列型)动态规划：
    lintcode 534
并不是所有的动态规划都显式的和前一个相关
    lintcode 149
可在同一天买入后卖出的股票类动态规划：
    lintcode 151
打印路径(用滚动数组也可以打印出路径，只不过太麻烦了，没去研究了):
    lintcode 110
有些动态规划类型，如果转移方程列的不对，根本进行不下去 lintcode 512

博弈型动态规划通常从第一步开始分析(即最后一步变成第一步了)，因为局面越来越简单 lingcode 394
    博弈型动态规划定义先手总是当前面对局面的那个人
背包问题   lintcode 92  lintcode 563 lintcode 564
    前i个物品能拼出的总重量(这里的总重量是指不超过背包容量的重量)为:
        1. 前i-1个物品能拼出的不超过背包容量总重量
        2. 前i-1个物品能拼出的总重量加上第i个物品的总重量(前提是不撑爆背包)
    n个物品能拼出的最大总重量即是背包能装下的最大重量
    dp[i][w] = dp[i-1][w] || dp[i-1][w-A[i]]

    可行性背包
    计数型背包 多少种方式
    最值型

    如果物品有顺序，看最后一个物品(相当于是当前)有没有进背包 表现在dp[i][w]是等于dp[i-1][w]还是dp[i-1][w-A[i-1]]
    如果物品没顺序，看最后一个物品(相当于是当前)是哪个，因为不论是第一个还是最后一个都可能选物品中的任何一个

    数组大小一定和最大承重有关
    主要看有没有放入顺序的区别，像组合计数就没有放入顺序区别

区间型
    按区间长度去算

    也可以用记忆化搜索方法
        自上而下递归
        没法用滚动数组之类的手段作空间优化

    消去型不要顺着题目的意思去做
动态规划怎么确定是不是子问题？
dp[i][j] = dp[i][j-2] 初始值不好确定的情况
### 额外的动态规划
357
698
